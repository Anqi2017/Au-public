#!/usr/bin/python
import sys, argparse, re

def main():
  parser = argparse.ArgumentParser(description = 'Combine junction_color.bed files generated by SpliceMap')
  parser.add_argument('bed_files',nargs='+',help='FILENAME for junction_color.bed files produced by SpliceMap')
  args = parser.parse_args()
  header = False
  entries = {}
  for file in args.bed_files:
    with open(file) as inf:
      for line in inf:
        f = line.rstrip().split()
        if f[1] == 'name=junctions':
          header = line.rstrip()
          continue
        id = f[0]+"\t"+f[1]+"\t"+f[2]+"\t"+f[5]
        if id not in entries:
          entries[id] = []
        entries[id].append(f)
  #We have sorted all the results
  final = {}
  for id in entries:
    #print id + "\t" + str(len(entries[id]))
    nR = 0
    width = 0
    max_nNR = 0
    min_nNR_to_nUR_ratio = 900000000
    nNR = 0
    nUR = 0
    nMR = 0
    for observation in entries[id]:
      snippit = observation[3]
      m = re.match('\((\d+)\)\[(\d+)_(\d+)\]\((\d+)\/(\d+)\)',snippit)
      if not m:
        sys.stderr.write("ERROR malformed snippit.\n"+snippit+"\n")
        return
      nR += int(m.group(1))
      if int(m.group(2)) > width: width = int(m.group(2))
      if int(m.group(4)) == 0: ratio = 0
      else: 
        ratio = float(m.group(3))/float(m.group(4))
      if ratio < min_nNR_to_nUR_ratio: min_nNR_to_nUR_ratio = ratio
      if int(m.group(3)) > max_nNR: max_nNR = int(m.group(3))
      nUR += int(m.group(4))
      nMR += int(m.group(5))
      # Here we estimate nNR by using whichever is better the max nNR
      # or a nUR scaled by the min ratio
    nNR = max([int(float(nUR)*min_nNR_to_nUR_ratio),max_nNR])
    new_snippit = '('+str(nR)+')['+str(width)+'_'+str(nNR)+']('+str(nUR)+'/'+str(nMR)+')'
    newobs = entries[id][0][:]
    newobs[3] = new_snippit
    # get sorting criteria
    chrom = newobs[0]
    start = int(newobs[1])
    finish = int(newobs[2])
    sign = newobs[5]
    if chrom not in final:
      final[chrom] = {}
    if start not in final[chrom]:
      final[chrom][start] = {}
    if finish not in final[chrom][start]:
      final[chrom][start][finish] = {}
    if sign not in final[chrom][start][finish]:
      final[chrom][start][finish][sign] = []
    final[chrom][start][finish][sign].append(newobs)
  #Finished going through it
  if header:
    print header
  for chrom in sorted(final):
    for start in sorted(final[chrom]):
      for finish in sorted(final[chrom][start]):
        for sign in sorted(final[chrom][start][finish]):
          for obs in final[chrom][start][finish][sign]:
            print "\t".join(obs)
  
main()
